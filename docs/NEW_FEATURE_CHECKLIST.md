# New Feature Development Checklist

Use this checklist when adding new features to UpStage to ensure architectural consistency and prevent regression bugs.

---

## 1. Backend Implementation (`backend/src`)

### A. New Agent Tool (If applicable)
- [ ] **Define Tool**: Add new tool definition in `agent/tools/index.ts` or separate file.
- [ ] **Parameters**: Ensure strict Zod schema for parameters.
- [ ] **Permission**: Check if `ToolContext` needs new fields (e.g., user DB access).
- [ ] **Image Handling**:
    - [ ] If inputting images: Use `resolveImage(args.image, context)` (uses `ImageStore`).
    - [ ] If generating images: Use `ImageStore.register()` in the result handling (in `orchestrator-claude.ts` usually handled automatically, but check return type).
- [ ] **Testing**: Test the tool in isolation if possible.

### B. API / Database
- [ ] **Endpoint**: Add new route in `api/` if needed.
- [ ] **Schema**: Update `db/schema.ts` if new data needs persistence.
    - [ ] Run migration: `npm run db:generate` & `npm run db:push`.
- [ ] **Streaming**: If feature requires real-time feedback, ensure `chat-stream.ts` handles the new event type.

---

## 2. iOS Implementation (`ios/Onstage`)

### A. Data Layer (`Sources/Domain`, `Sources/Data`)
- [ ] **Entity**: Update `Message` or `User` struct if new fields added.
- [ ] **DTO**: Update `ChatRepository.swift` and `AgentStepDTO` to parse new JSON fields from backend.
    - [ ] **CRITICAL**: Ensure new fields are Optional (`?`) to prevent crashing on old messages.

### B. Presentation Layer (`Sources/Presentation`)
- [ ] **ViewModel**: Update `ChatViewModel.swift`.
    - [ ] **State**: Add published properties for new UI state.
    - [ ] **Streaming**: Handle new SSE event types in `handleMessageStream`.
- [ ] **Block Factory**: Update `MessageBlockFactory` (in `ChatViewModel.swift`)!
    - [ ] **CRITICAL**: If this feature adds a new message component, you **MUST** add it to `MessageBlockFactory.createBlocks`.
    - [ ] **Validation**: Ensure blocks generated by Factory match those generated during Streaming.
- [ ] **UI**: Create/Update SwiftUI Views.
    - [ ] Use `DesignSystem` components.

---

## 3. Integration & Verification

### A. Core Flows
- [ ] **Streaming Test**: Run the feature. Does it appear correct *while* generating?
- [ ] **Reload Test**: Kill the app and restart. Does the feature *reappear* correctly from history?
    - [ ] If disappearing: Check `ChatRepository` decoding or `MessageBlockFactory` logic.
    - [ ] If reordering: Check `MessageBlockFactory` order.
- [ ] **Image Test**:
    - [ ] If involving images, verify "Tap to Expand" works.
    - [ ] Verify images persist after reload (URL extraction correct?).

### B. Compatibility
- [ ] **Old Clients**: Does this break existing app versions? (API backward compatibility).

---

## 4. Common Pitfalls (Read Before Committing)

- ❌ **Do NOT use `UUID()` for Tool Blocks**: Always use `step.id` from the backend. Using random UUIDs causes UI flicker and state reset on reload.
- ❌ **Do NOT bypass `ImageStore`**: Never parse `/api/chat/assets` manually. Use `resolveImage` helper.
- ❌ **Do NOT hardcode colors**: Use `Theme` system in iOS.
- ❌ **Do NOT forget `thinking` field**: Backend stores thoughts separately from content. Ensure iOS parses both.
